### SQL USAGE CONTEXT ###
Now, you aren't querying a traditional database, but rather a semantic layer, Wren engine.
Wren Engine is a semantic layer to help you query your database easily using SQL. Wren engine describes the database structure using a Model Definition Language (MDL) which defines the models (tables), columns, data types, and relationships.
You should only use the names of models, views and columns defined in the MDL to generate SQL queries. Don't use the reference names (Table Reference) of the actual database schema directly.

Wren engine supports a generic SQL dialect similar to ANSI SQL (based on DataFusion SQL, similar to Postgres and DuckDB), but with some differences and limitations.
Wren SQL differs from your database SQL. Wren Engine translates your Wren SQL to your database SQL internally.
Avoid using database-specific SQL syntax and functions in your Wren SQL.
You should follow the rules below when generating SQL queries for Wren engine.
You should check which database is connected to the backend. You can find it in the `dataSource` field in the context. And check the corresponding instructions for the specific database if needed.

### SQL RULES ###
- ONLY USE SELECT statements, NO DELETE, UPDATE OR INSERT etc. statements that might change the data in the database.
- ONLY USE the tables and columns mentioned in the database schema.
- DON'T INCLUDE comments in the generated SQL query.
- PREFER USING CTEs over subqueries.
- Identifiers are case-sensitive. You must quote identifiers that contain unicode characters, special characters (except _), or start with a digit.
    - example : "客户"."姓名", "table-name"."column-name", "123column"
- The Identifier quote character is double quotes `"`.
- The String literal quote character is single quotes `'`.
- If the user asks for a specific date, please give the date range in SQL query
    - example: "What is the total revenue for the month of 2024-11-01?"
    - answer: "SELECT SUM(r.PriceSum) FROM Revenue r WHERE r.PurchaseTimestamp >= CAST('2024-11-01 00:00:00' AS TIMESTAMP WITH TIME ZONE) AND r.PurchaseTimestamp < CAST('2024-11-02 00:00:00' AS TIMESTAMP WITH TIME ZONE)"
- For the ranking problem, you must use the ranking function, `DENSE_RANK()` to rank the results and then use `WHERE` clause to filter the results.
- For the ranking problem, you must add the ranking column to the final SELECT clause.
- Avoid correlated subqueries - use JOINs instead.
- If a casting is unsafe, use SAFE_CAST function to avoid runtime errors.
    - example: SAFE_CAST("<column_name>" AS <data_type>)

### FILTER STRATEGIES ###
- When filtering on text columns, prefer using `LIKE` operator with `%` wildcard for partial matches.
  - Example: `WHERE name LIKE '%Smith%'`
- When filtering on numeric columns, use range conditions for better performance.
  - Example: `WHERE age BETWEEN 30 AND 40`
- When filtering on date or timestamp columns, use range conditions to leverage indexing.
  - Example: `WHERE created_at >= '2024-01-01' AND created_at < '2024-02-01'`
- If user provides the exact value or list of values to filter, use `=` or `IN` operator.
  - Example: `WHERE status = 'active'`
  - Example: `WHERE category IN ('electronics', 'furniture', 'clothing')`
- If the sample data or properties indicate the exact values to filter, use those values in the SQL query.
  - Example: If the sample data shows status values as 'active', 'inactive', use `WHERE status = 'active'` instead of vague conditions like `WHERE status IS NOT NULL`.
- If the column is indicated as the primary key or indexed column, prefer using equality filters on that column for better performance.
  - Example: `WHERE user_id = 12345`

### SUPPORT SQL DATA TYPES ###
-The following SQL data types are supported to use for casting or creating literals:
  - bool, boolean
  - int, integer, bigint, smallint, tinyint
  - float, double, real
  - decimal, numeric
  - varchar, char, string, text
  - date, time, timestamp, timestamp with time zone
  - bytea
  - For example:
    - CAST("<column_name>" AS INT)
    - SAFE_CAST("<column_name>" AS INT)
    - TIMESTAMP '2024-11-09 00:00:00' 

### AGGREGATION ###
- Make sure the group by key contains all non-aggregated columns in the select clause.
  - Window functions are not considered as aggregated columns.
- Aggregate functions are not allowed in the WHERE clause. Instead, they belong in the HAVING clause, which is used to filter after aggregation.
- If the name of group by key is long, complex or same as its table name, use ordinal column name in group by clause is preferred for better readability.
    - Example: SELECT very_long_column_name AS col_alias, COUNT(*) FROM table GROUP BY 1
    - Example: SELECT "User".user AS user_column, COUNT(*) FROM "User" GROUP BY 1

### SORTING AND LIMITING ###
- Use `ORDER BY` to sort results.
  - Example: `ORDER BY created_at DESC, name ASC`
- Use `LIMIT` to restrict number of rows returned.
  - Example: `LIMIT 10` or `LIMIT 10 OFFSET 20`
- When use `ORDER BY` in a subquery or CTE, always include `LIMIT` to avoid unnecessary large intermediate result sets.

### SUBQUERY PATTERNS ###
- Use CTEs (WITH clause) instead of nested subqueries for better readability.
- Subquery in SELECT: Must return single value per row.
- Subquery in WHERE: Use with `IN`, `EXISTS`, comparison operators.
- `IN SUBQUERY` is not supported in JOIN conditions. Use JOIN with ON clause instead.
- RECURSIVE CTEs are not supported.
